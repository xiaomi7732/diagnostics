{"version":3,"sources":["Components/Processes.tsx","Components/TraceSessions.tsx","Components/TraceRepo.tsx","Components/ConnectingToBackend.tsx","Components/AppHeader.tsx","Components/ConnectionStatus.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Processes","handleRefresh","event","a","preventDefault","stopPropagation","props","refreshProcessAsync","content","len","undefined","this","processArray","length","map","process","index","className","key","id","name","mainModule","type","value","onClick","console","debug","startProfilingAsync","Component","TraceSessions","list","traceSessions","session","processId","sessionId","stopProfilingAsync","defaultValue","loadTraceSessionsAsync","PureComponent","TraceRepo","fileArray","sort","b","fileName","file","fileFormat","toLowerCase","endsWith","href","baseUrl","sizeInBytes","convertToSpeedscopeAsync","loadTraceFilesAsync","target","rel","ConnectingToBackend","handleConnectAsync","url","setState","errorMessage","isConnecting","connectToBackendAsync","handleAddBackend","e","newValue","newBackend","addBackend","newUrl","handleNewUrlChanged","state","backendUrlArray","removeBackend","onSubmit","htmlFor","placeholder","onChange","AppHeader","ConnectionStatus","disconnectBackend","App","BackendListKey","initializeAsync","Promise","all","loadProcessesAsync","isReady","getProcessesAsync","processes","fetch","response","ok","json","results","method","headers","body","JSON","stringify","result","getTraceSessionsAsync","traceSessionArray","getTraceFilesAsync","files","traceFileArray","error","alert","getList","includes","push","localStorage","setItem","filter","item","isBackendReady","trim","startsWith","substring","urlListSerialized","getItem","parse","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c885c981.chunk.js","sourcesContent":["import React, { Component, ReactNode } from 'react';\r\nimport Process from '../Models/Process';\r\nimport './Processes.css';\r\n\r\ninterface ProcessesProps {\r\n    refreshProcessAsync: () => Promise<void>;\r\n    startProfilingAsync: (processId: number) => Promise<boolean>;\r\n    processArray: Process[] | undefined;\r\n}\r\n\r\nexport default class Processes extends Component<ProcessesProps, {}>{\r\n    render(): ReactNode {\r\n        let content;\r\n        let len = 0;\r\n\r\n        if (this.props.processArray === undefined || this.props.processArray.length === 0) {\r\n            content = (<div>\r\n                There is no .NET Core processes.\r\n            </div>);\r\n        } else {\r\n            len = this.props.processArray.length;\r\n            content = this.props.processArray.map((process: Process, index: number) => {\r\n                return (<div className='process-line' key={index}>\r\n                    <span className='process-id'>{process.id}</span> <span className='process-name'>{process.name}</span> <span className='process-path'>{process.mainModule}</span>\r\n                    <input className='button' type='button' value='Start Profiling'\r\n                        onClick={() => {\r\n                            console.debug(`Start Profiling for session: ${process.id}`)\r\n                            this.props.startProfilingAsync(process.id)\r\n                        }} />\r\n                </div>)\r\n            });\r\n        }\r\n\r\n        return (<div className='processes'>\r\n            <div className='header'>\r\n                <h2>Remote Process ({len})</h2>\r\n                <input className='button header-button refresh-button' type='button' onClick={this.handleRefresh} value='&#x1f5d8;'></input>\r\n            </div>\r\n            {content}\r\n        </div>\r\n        );\r\n    }\r\n\r\n    private handleRefresh = async (event: React.MouseEvent<HTMLInputElement, MouseEvent>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.props.refreshProcessAsync();\r\n    }\r\n}\r\n\r\n\r\n","import React, { PureComponent } from 'react';\r\nimport { TraceSession } from '../Models/TraceSession';\r\nimport './TraceSessions.css';\r\n\r\ninterface TraceSessionsProps {\r\n    loadTraceSessionsAsync: () => Promise<void>;\r\n    stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean>;\r\n    traceSessions: TraceSession[] | undefined;\r\n}\r\n\r\nexport default class TraceSessions extends PureComponent<TraceSessionsProps, {}>{\r\n    render() {\r\n        let list;\r\n        let len: number = 0;\r\n\r\n        if (this.props.traceSessions === undefined || this.props.traceSessions.length === 0) {\r\n            list = <div>There's no trace sessions.</div>\r\n        }\r\n        else {\r\n            len = this.props.traceSessions.length;\r\n            list = <div className='session-container'>\r\n                {this.props.traceSessions.map((session, index) => {\r\n                    return (<div className='session-line' key={index}>\r\n                        <div className='process-id-part'>\r\n                            <span className='bold-text'>ProcessId:</span>\r\n                            <span>{session.processId}</span>&nbsp;\r\n                        </div>\r\n                        <div className='session-id-part'>\r\n                            <span className='bold-text'>SessionId:</span>\r\n                            <span>{session.sessionId}</span>&nbsp;\r\n                        </div>\r\n                        <input className='button' type='button' value='Stop Profiling' onClick={() => {\r\n                            console.debug(`Stopping profiler: ${session.processId}:${session.sessionId}`);\r\n                            this.props.stopProfilingAsync(session.processId, session.sessionId);\r\n                        }} />\r\n                    </div>);\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div className='trace-session'>\r\n            <div className='header'>\r\n                <h2>Remote Trace Sessions ({len})</h2>\r\n                <input className='button header-button' type='button' defaultValue='&#x1f5d8;' onClick={this.props.loadTraceSessionsAsync} />\r\n            </div>\r\n            {list}\r\n        </div>);\r\n    }\r\n}","import React, { PureComponent } from 'react';\r\nimport TraceFile from '../Models/TraceFile';\r\nimport './TraceRepo.css';\r\n\r\ninterface TraceRepoProps {\r\n    baseUrl: string;\r\n    loadTraceFilesAsync: () => Promise<void>;\r\n    convertToSpeedscopeAsync: (fileName: string) => Promise<boolean>;\r\n    fileArray: TraceFile[] | undefined;\r\n}\r\n\r\nexport default class TraceRepo extends PureComponent<TraceRepoProps, {}>{\r\n    render() {\r\n        let content;\r\n        let len: number = 0;\r\n        if (this.props.fileArray === undefined || this.props.fileArray.length === 0) {\r\n            content = <div>There's no trace file.</div>\r\n        } else {\r\n            len = this.props.fileArray.length;\r\n            content = <div>\r\n                {this.props.fileArray.sort((a, b) => {\r\n                    return a.fileName > b.fileName ? -1 : 1;\r\n                }).map((file, index) => {\r\n                    const fileFormat = file.fileName.toLowerCase().endsWith('.nettrace') ? 'nettrace' : 'speedscope';\r\n                    return <div key={index} className='trace-file-line'>\r\n                        <div className='trace-file'>\r\n                            <a href={`${this.props.baseUrl}/TraceFiles/${file.fileName}`}>{file.fileName}</a>\r\n                        </div>\r\n                        <div className='trace-file-size'>\r\n                            {file.sizeInBytes} bytes\r\n                        </div>\r\n                        {(fileFormat === 'nettrace') && <input className='button' type='button' value='Get speedscope file' onClick={() => this.props.convertToSpeedscopeAsync(file.fileName)}></input>}\r\n                        {/* <input className='button' type='button' value='Upload to SP Backend' onClick={() => alert(`Not implemented: ${file.fileName}`)} /> */}\r\n                    </div>\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div className='trace-repo'>\r\n            <div className='header'>\r\n                <h2>Remote Trace Files ({len})</h2>\r\n                <input className='button header-button' type='button' value='&#x1f5d8;' onClick={async () => await this.props.loadTraceFilesAsync()}></input>\r\n            </div>\r\n            <div className='speed-scope-tips'>\r\n                To open trace in <a href='https://speedscope.app' target='_blank' rel='noopener noreferrer'>speedscope</a>, download the <span>speedscope.json</span> files to your local box and upload it to <a href='https://speedscope.app' target='_blank' rel='noopener noreferrer'>speedscope.app</a>.\r\n            </div>\r\n            {content}\r\n        </div>)\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './ConnectingToBackend.css';\r\n\r\ninterface ConnectingToBackendProps {\r\n    backendUrlArray: string[] | undefined,\r\n    connectToBackendAsync: (url: string) => Promise<boolean>;\r\n    addBackend: (newUrl: string) => void;\r\n    removeBackend: (targetUrl: string) => void;\r\n}\r\n\r\ninterface ConnectingToBackendState {\r\n    errorMessage: string | undefined;\r\n    isConnecting: boolean;\r\n    newUrl: string;\r\n}\r\n\r\nexport default class ConnectingToBackend extends Component<ConnectingToBackendProps, ConnectingToBackendState>{\r\n    constructor(props: ConnectingToBackendProps) {\r\n        super(props);\r\n        this.state = {\r\n            errorMessage: undefined,\r\n            isConnecting: false,\r\n            newUrl: '',\r\n        };\r\n    }\r\n\r\n    render() {\r\n        let content;\r\n        if (this.props.backendUrlArray === undefined || this.props.backendUrlArray.length === 0) {\r\n            content = <div>Please add backend.</div>\r\n        } else {\r\n            content = this.props.backendUrlArray.map((url, index) => {\r\n                return <div className='backend-item-container' key={index}>\r\n                    <span className='backend-url' onClick={async () => {\r\n                        await this.handleConnectAsync(url);\r\n                    }}>{url}</span>\r\n                    <input className='button' type='button' value='Connect' onClick={async () => {\r\n                        await this.handleConnectAsync(url);\r\n                    }}></input>\r\n                    <input className='button' type='button' value='Remove' onClick={async () => {\r\n                        this.props.removeBackend(url);\r\n                    }}></input>\r\n                </div>\r\n            })\r\n        }\r\n\r\n        return (\r\n            <div className='connect-backend'>\r\n                <h2>Pick a backend</h2>\r\n                {content}\r\n                {!!this.state.isConnecting && <div>Connecting . . .</div>}\r\n                {!!this.state.errorMessage && <div>{this.state.errorMessage}</div>}\r\n\r\n                <h2>Adding new Backend</h2>\r\n                <div className='new-endpoint-container'>\r\n                    <form onSubmit={this.handleAddBackend}>\r\n                        <label htmlFor='newBackend'>Type in a new endpoint:</label>\r\n                        <input className='text-input' id='newBackend' type='textbox' placeholder='http://localhost:9400'\r\n                            value={this.state.newUrl} onChange={this.handleNewUrlChanged} />\r\n                        <div>\r\n                            <span className='tips'>Tips: Press enter to add the endpoint.</span>\r\n                        </div>\r\n                    </form>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    handleConnectAsync = async (url: string) => {\r\n        this.setState({\r\n            errorMessage: '',\r\n            isConnecting: true,\r\n        });\r\n        const result = await this.props.connectToBackendAsync(url);\r\n        if (!result) {\r\n            this.setState({\r\n                errorMessage: `Failed to connecting to backend: ${url}.`,\r\n                isConnecting: false,\r\n            });\r\n        }\r\n    }\r\n\r\n    handleAddBackend = (e: React.FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        const target = e.target as any;\r\n        const newValue = target.newBackend.value;\r\n        if (!!newValue) {\r\n            this.props.addBackend(newValue);\r\n            this.setState({\r\n                newUrl: ''\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNewUrlChanged = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({\r\n            newUrl: e.target.value,\r\n        });\r\n    }\r\n}","import React from 'react';\r\nexport const AppHeader = () => (\r\n    <div className='app-header'>\r\n        <h1>.NET Core Profiling Console</h1>\r\n    </div>\r\n);","import React from 'react';\r\n\r\ninterface ConnectionStatusProps {\r\n    baseUrl: string;\r\n\r\n    disconnectBackend: () => void;\r\n}\r\n\r\nexport const ConnectionStatus = (props: ConnectionStatusProps) => (\r\n    <div className='connection-status'>\r\n        <h2>Connection</h2>\r\n        <span>&#x1f5a7; You are connecting to: {props.baseUrl}</span>\r\n        <input className='button' type='button' onClick={props.disconnectBackend} value='Disconnect'></input>\r\n    </div>\r\n);","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport './Components/Processes'\r\nimport Process from './Models/Process';\r\nimport { TraceSession } from './Models/TraceSession';\r\n\r\nimport Processes from './Components/Processes';\r\nimport TraceSessions from './Components/TraceSessions';\r\nimport TraceFile from './Models/TraceFile';\r\nimport TraceRepo from './Components/TraceRepo';\r\nimport ConnectingToBackend from './Components/ConnectingToBackend';\r\nimport { AppHeader } from './Components/AppHeader';\r\nimport { ConnectionStatus } from './Components/ConnectionStatus';\r\n\r\ninterface AppState {\r\n  processArray: Process[] | undefined;\r\n  traceSessionArray: TraceSession[] | undefined;\r\n  traceFileArray: TraceFile[] | undefined;\r\n  isReady: boolean;\r\n  isBackendReady: boolean;\r\n  backendUrlArray: string[];\r\n  baseUrl: string;\r\n}\r\n\r\nexport default class App extends Component<any, AppState>{\r\n  readonly BackendListKey: string = 'backendList';\r\n  constructor(props: any) {\r\n    super(props);\r\n\r\n    // Initial state\r\n    this.state = {\r\n      processArray: undefined,\r\n      traceSessionArray: undefined,\r\n      traceFileArray: undefined,\r\n      isReady: false,\r\n      isBackendReady: false,\r\n      backendUrlArray: this.getList(),\r\n      baseUrl: '',\r\n    };\r\n  }\r\n  render() {\r\n    let content;\r\n\r\n    if (!this.state.isBackendReady) {\r\n      content = <ConnectingToBackend\r\n        backendUrlArray={this.state.backendUrlArray}\r\n        addBackend={this.addBackend}\r\n        removeBackend={this.removeBackend}\r\n        connectToBackendAsync={this.connectToBackendAsync}\r\n      />;\r\n    } else {\r\n      content = this.state.isReady ? (\r\n        <div>\r\n          <ConnectionStatus baseUrl={this.state.baseUrl}\r\n            disconnectBackend={this.disconnectBackend}\r\n          />\r\n          <Processes\r\n            refreshProcessAsync={this.loadProcessesAsync}\r\n            startProfilingAsync={this.startProfilingAsync}\r\n            processArray={this.state.processArray}\r\n          />\r\n          <TraceSessions\r\n            traceSessions={this.state.traceSessionArray}\r\n            stopProfilingAsync={this.stopProfilingAsync}\r\n            loadTraceSessionsAsync={this.loadTraceSessionsAsync} />\r\n          <TraceRepo\r\n            baseUrl={this.state.baseUrl}\r\n            loadTraceFilesAsync={this.loadTraceFilesAsync}\r\n            convertToSpeedscopeAsync={this.convertToSpeedscopeAsync}\r\n            fileArray={this.state.traceFileArray}\r\n          />\r\n        </div>\r\n      ) : null;\r\n    }\r\n\r\n    return (\r\n      <div className='dark-theme'>\r\n        <AppHeader />\r\n        <div className='app-container'>\r\n          {content}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private initializeAsync: () => Promise<any> = async () => {\r\n    await Promise.all([\r\n      this.loadProcessesAsync(),\r\n      this.loadTraceSessionsAsync(),\r\n      this.loadTraceFilesAsync(),\r\n    ]);\r\n\r\n    this.setState({\r\n      isReady: true,\r\n    });\r\n  }\r\n\r\n  // Processes\r\n  private loadProcessesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const processes = await this.getProcessesAsync();\r\n      this.setState({\r\n        processArray: processes,\r\n      });\r\n    } catch (ex) {\r\n      this.setState({\r\n        processArray: undefined,\r\n      });\r\n    }\r\n  }\r\n  private getProcessesAsync: () => Promise<Process[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/processes`);\r\n    if (!!response && response.ok) {\r\n      const results: Process[] = await response.json();\r\n      return results;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Traces\r\n  private startProfilingAsync: (processId: number) => Promise<boolean> = async (processId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        processId: processId\r\n      }),\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await this.loadTraceSessionsAsync();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean> = async (processId: number, sessionId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces/${processId}?sessionId=${sessionId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await Promise.all([this.loadTraceSessionsAsync(), this.loadTraceFilesAsync()]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Sessions\r\n  private loadTraceSessionsAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const traceSessions = await this.getTraceSessionsAsync();\r\n      this.setState({\r\n        traceSessionArray: traceSessions,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceSessionArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceSessionsAsync: () => Promise<TraceSession[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/sessions`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceSession[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Repository\r\n  private loadTraceFilesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const files = await this.getTraceFilesAsync();\r\n      this.setState({\r\n        traceFileArray: files,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceFileArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceFilesAsync: () => Promise<TraceFile[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/traceFiles`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceFile[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  private convertToSpeedscopeAsync: (fileName: string) => Promise<boolean> = async (fileName) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traceFiles`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        fileName,\r\n      }),\r\n    });\r\n    if (!!response && response.ok) {\r\n      await this.loadTraceFilesAsync();\r\n      return true;\r\n    } else {\r\n      const error = await response.json();\r\n\r\n      alert('Converting failed.' + !!error.error ? ' Details: ' + error.error : '');\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Backend\r\n  private addBackend: (url: string) => void = (url: string) => {\r\n    url = url.toLowerCase();\r\n    const list = this.getList();\r\n    if (!list.includes(url)) {\r\n      list.push(url);\r\n    }\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private removeBackend: (url: string) => void = (url: string): void => {\r\n    url = url.toLowerCase();\r\n    let list = this.getList();\r\n    list = list.filter(item => item !== url);\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private getList(): string[] {\r\n    const urlListSerialized: string | null = localStorage.getItem(this.BackendListKey);\r\n    let list: string[];\r\n    if (urlListSerialized === null || urlListSerialized === '' || urlListSerialized === '[]') {\r\n      list = ['http://localhost:9400'];\r\n    } else {\r\n      list = JSON.parse(urlListSerialized);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  private disconnectBackend: () => void = () => {\r\n    this.setState({\r\n      baseUrl: '',\r\n      isReady: false,\r\n      isBackendReady: false,\r\n    });\r\n  }\r\n\r\n  private connectToBackendAsync: (url: string) => Promise<boolean> = async (url: string) => {\r\n    try {\r\n      url = url.trim();\r\n      if (!url.startsWith('http') && !url.startsWith('https')) {\r\n        return false;\r\n      }\r\n      if (url.endsWith('/')) {\r\n        url = url.substring(0, url.length - 1);\r\n      }\r\n      const response = await fetch(url + '/processes');\r\n      if (!!response && response.ok) {\r\n        this.setState({\r\n          isBackendReady: true,\r\n          baseUrl: url,\r\n        });\r\n        await this.initializeAsync();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}