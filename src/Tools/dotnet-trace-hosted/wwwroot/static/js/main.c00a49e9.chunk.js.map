{"version":3,"sources":["Components/Processes.tsx","Components/TraceSessions.tsx","Components/TraceRepo.tsx","Components/ConnectingToBackend.tsx","Components/AppHeader.tsx","Components/ConnectionStatus.tsx","Components/ProfilePicker.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Processes","handleRefresh","event","a","preventDefault","stopPropagation","props","refreshProcessAsync","content","len","undefined","this","processArray","length","map","process","index","className","key","id","name","mainModule","type","value","onClick","console","debug","startProfilingAsync","takeDumpAsync","Component","TraceSessions","list","traceSessions","session","processId","sessionId","stopProfilingAsync","defaultValue","loadTraceSessionsAsync","PureComponent","TraceRepo","fileArray","sort","b","fileName","file","fileFormat","toLowerCase","endsWith","href","baseUrl","sizeInBytes","convertToSpeedscopeAsync","loadTraceFilesAsync","target","rel","ConnectingToBackend","handleConnectAsync","url","setState","errorMessage","isConnecting","connectToBackendAsync","handleAddBackend","e","newValue","newBackend","addBackend","newUrl","handleNewUrlChanged","state","backendUrlArray","removeBackend","onSubmit","htmlFor","placeholder","onChange","AppHeader","ConnectionStatus","disconnectBackend","ProfileViewer","getValidProfile","profileArray","filter","p","count","selectedProfile","onSelected","profile","description","onRefresh","App","BackendListKey","initializeAsync","Promise","all","loadProcessesAsync","LoadProfilesAsync","selectProfile","isReady","getProcessesAsync","processes","fetch","response","ok","json","results","method","headers","body","JSON","stringify","result","getTraceSessionsAsync","traceSessionArray","getTraceFilesAsync","files","traceFileArray","error","alert","getList","includes","push","localStorage","setItem","item","isBackendReady","trim","startsWith","substring","getProfilesAsync","isMini","dumpType","urlListSerialized","getItem","parse","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c00a49e9.chunk.js","sourcesContent":["import React, { Component, ReactNode } from 'react';\r\nimport Process from '../Models/Process';\r\nimport './Processes.css';\r\n\r\ninterface ProcessesProps {\r\n    refreshProcessAsync: () => Promise<void>;\r\n    startProfilingAsync: (processId: number) => Promise<boolean>;\r\n    takeDumpAsync: (processId: number, isMini: boolean) => Promise<boolean>;\r\n    processArray: Process[] | undefined;\r\n}\r\n\r\nexport default class Processes extends Component<ProcessesProps, {}>{\r\n    render(): ReactNode {\r\n        let content;\r\n        let len = 0;\r\n\r\n        if (this.props.processArray === undefined || this.props.processArray.length === 0) {\r\n            content = (<div>\r\n                There is no .NET Core processes.\r\n            </div>);\r\n        } else {\r\n            len = this.props.processArray.length;\r\n            content = this.props.processArray.map((process: Process, index: number) => {\r\n                return (<div className='process-line' key={index}>\r\n                    <span className='process-id'>{process.id}</span> <span className='process-name'>{process.name}</span> <span className='process-path'>{process.mainModule}</span>\r\n                    <input className='button' type='button' value='Start Profiling'\r\n                        onClick={() => {\r\n                            console.debug(`Start Profiling for session: ${process.id}`)\r\n                            this.props.startProfilingAsync(process.id)\r\n                        }} />\r\n\r\n                    <input className='button' type='button' value='Mini Dump'\r\n                        onClick={async () => {\r\n                            await this.props.takeDumpAsync(process.id, true)\r\n                        }} />\r\n                    <input className='button' type='button' value='Heap Dump'\r\n                        onClick={() => {\r\n                            this.props.takeDumpAsync(process.id, false)\r\n                        }} />\r\n                </div>)\r\n            });\r\n        }\r\n\r\n        return (<div className='processes'>\r\n            <div className='header'>\r\n                <h2>Remote Process ({len})</h2>\r\n                <input className='button header-button refresh-button' type='button' onClick={this.handleRefresh} value='&#x1f5d8;'></input>\r\n            </div>\r\n            {content}\r\n        </div>\r\n        );\r\n    }\r\n\r\n    private handleRefresh = async (event: React.MouseEvent<HTMLInputElement, MouseEvent>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.props.refreshProcessAsync();\r\n    }\r\n}\r\n\r\n\r\n","import React, { PureComponent } from 'react';\r\nimport { TraceSession } from '../Models/TraceSession';\r\nimport './TraceSessions.css';\r\n\r\ninterface TraceSessionsProps {\r\n    loadTraceSessionsAsync: () => Promise<void>;\r\n    stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean>;\r\n    traceSessions: TraceSession[] | undefined;\r\n}\r\n\r\nexport default class TraceSessions extends PureComponent<TraceSessionsProps, {}>{\r\n    render() {\r\n        let list;\r\n        let len: number = 0;\r\n\r\n        if (this.props.traceSessions === undefined || this.props.traceSessions.length === 0) {\r\n            list = <div>There's no trace sessions.</div>\r\n        }\r\n        else {\r\n            len = this.props.traceSessions.length;\r\n            list = <div className='session-container'>\r\n                {this.props.traceSessions.map((session, index) => {\r\n                    return (<div className='session-line' key={index}>\r\n                        <div className='process-id-part'>\r\n                            <span className='bold-text'>ProcessId:</span>\r\n                            <span>{session.processId}</span>&nbsp;\r\n                        </div>\r\n                        <div className='session-id-part'>\r\n                            <span className='bold-text'>SessionId:</span>\r\n                            <span>{session.sessionId}</span>&nbsp;\r\n                        </div>\r\n                        <input className='button' type='button' value='Stop Profiling' onClick={() => {\r\n                            console.debug(`Stopping profiler: ${session.processId}:${session.sessionId}`);\r\n                            this.props.stopProfilingAsync(session.processId, session.sessionId);\r\n                        }} />\r\n                    </div>);\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div className='trace-session'>\r\n            <div className='header'>\r\n                <h2>Remote Trace Sessions ({len})</h2>\r\n                <input className='button header-button' type='button' defaultValue='&#x1f5d8;' onClick={this.props.loadTraceSessionsAsync} />\r\n            </div>\r\n            {list}\r\n        </div>);\r\n    }\r\n}","import React, { PureComponent } from 'react';\r\nimport TraceFile from '../Models/TraceFile';\r\nimport './TraceRepo.css';\r\n\r\ninterface TraceRepoProps {\r\n    baseUrl: string;\r\n    loadTraceFilesAsync: () => Promise<void>;\r\n    convertToSpeedscopeAsync: (fileName: string) => Promise<boolean>;\r\n    fileArray: TraceFile[] | undefined;\r\n}\r\n\r\nexport default class TraceRepo extends PureComponent<TraceRepoProps, {}>{\r\n    render() {\r\n        let content;\r\n        let len: number = 0;\r\n        if (this.props.fileArray === undefined || this.props.fileArray.length === 0) {\r\n            content = <div>There's no trace file.</div>\r\n        } else {\r\n            len = this.props.fileArray.length;\r\n            content = <div>\r\n                {this.props.fileArray.sort((a, b) => {\r\n                    return a.fileName > b.fileName ? -1 : 1;\r\n                }).map((file, index) => {\r\n                    const fileFormat = file.fileName.toLowerCase().endsWith('.nettrace') ? 'nettrace' : 'speedscope';\r\n                    return <div key={index} className='trace-file-line'>\r\n                        <div className='trace-file'>\r\n                            <a href={`${this.props.baseUrl}/TraceFiles/${file.fileName}`}>{file.fileName}</a>\r\n                        </div>\r\n                        <div className='trace-file-size'>\r\n                            {file.sizeInBytes} bytes\r\n                        </div>\r\n                        {(fileFormat === 'nettrace') && <input className='button' type='button' value='Get speedscope file' onClick={() => this.props.convertToSpeedscopeAsync(file.fileName)}></input>}\r\n                        {/* <input className='button' type='button' value='Upload to SP Backend' onClick={() => alert(`Not implemented: ${file.fileName}`)} /> */}\r\n                    </div>\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div className='trace-repo'>\r\n            <div className='header'>\r\n                <h2>Remote Trace Files ({len})</h2>\r\n                <input className='button header-button' type='button' value='&#x1f5d8;' onClick={async () => await this.props.loadTraceFilesAsync()}></input>\r\n            </div>\r\n            <div className='speed-scope-tips'>\r\n                To open trace in <a href='https://speedscope.app' target='_blank' rel='noopener noreferrer'>speedscope</a>, download the <span>speedscope.json</span> files to your local box and upload it to <a href='https://speedscope.app' target='_blank' rel='noopener noreferrer'>speedscope.app</a>.\r\n            </div>\r\n            {content}\r\n        </div>)\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './ConnectingToBackend.css';\r\n\r\ninterface ConnectingToBackendProps {\r\n    backendUrlArray: string[] | undefined,\r\n    connectToBackendAsync: (url: string) => Promise<boolean>;\r\n    addBackend: (newUrl: string) => void;\r\n    removeBackend: (targetUrl: string) => void;\r\n}\r\n\r\ninterface ConnectingToBackendState {\r\n    errorMessage: string | undefined;\r\n    isConnecting: boolean;\r\n    newUrl: string;\r\n}\r\n\r\nexport default class ConnectingToBackend extends Component<ConnectingToBackendProps, ConnectingToBackendState>{\r\n    constructor(props: ConnectingToBackendProps) {\r\n        super(props);\r\n        this.state = {\r\n            errorMessage: undefined,\r\n            isConnecting: false,\r\n            newUrl: '',\r\n        };\r\n    }\r\n\r\n    render() {\r\n        let content;\r\n        if (this.props.backendUrlArray === undefined || this.props.backendUrlArray.length === 0) {\r\n            content = <div>Please add backend.</div>\r\n        } else {\r\n            content = this.props.backendUrlArray.map((url, index) => {\r\n                return <div className='backend-item-container' key={index}>\r\n                    <span className='backend-url' onClick={async () => {\r\n                        await this.handleConnectAsync(url);\r\n                    }}>{url}</span>\r\n                    <input className='button' type='button' value='Connect' onClick={async () => {\r\n                        await this.handleConnectAsync(url);\r\n                    }}></input>\r\n                    <input className='button' type='button' value='Remove' onClick={async () => {\r\n                        this.props.removeBackend(url);\r\n                    }}></input>\r\n                </div>\r\n            })\r\n        }\r\n\r\n        return (\r\n            <div className='connect-backend'>\r\n                <h2>Pick a backend</h2>\r\n                {content}\r\n                {!!this.state.isConnecting && <div>Connecting . . .</div>}\r\n                {!!this.state.errorMessage && <div>{this.state.errorMessage}</div>}\r\n\r\n                <h2>Adding new Backend</h2>\r\n                <div className='new-endpoint-container'>\r\n                    <form onSubmit={this.handleAddBackend}>\r\n                        <label htmlFor='newBackend'>Type in a new endpoint:</label>\r\n                        <input className='text-input' id='newBackend' type='textbox' placeholder='http://localhost:9400'\r\n                            value={this.state.newUrl} onChange={this.handleNewUrlChanged} />\r\n                        <div>\r\n                            <span className='tips'>Tips: Press enter to add the endpoint.</span>\r\n                        </div>\r\n                    </form>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    handleConnectAsync = async (url: string) => {\r\n        this.setState({\r\n            errorMessage: '',\r\n            isConnecting: true,\r\n        });\r\n        const result = await this.props.connectToBackendAsync(url);\r\n        if (!result) {\r\n            this.setState({\r\n                errorMessage: `Failed to connecting to backend: ${url}.`,\r\n                isConnecting: false,\r\n            });\r\n        }\r\n    }\r\n\r\n    handleAddBackend = (e: React.FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        const target = e.target as any;\r\n        const newValue = target.newBackend.value;\r\n        if (!!newValue) {\r\n            this.props.addBackend(newValue);\r\n            this.setState({\r\n                newUrl: ''\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNewUrlChanged = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({\r\n            newUrl: e.target.value,\r\n        });\r\n    }\r\n}","import React from 'react';\r\nexport const AppHeader = () => (\r\n    <div className='app-header'>\r\n        <h1>.NET Core Profiling Console</h1>\r\n    </div>\r\n);","import React from 'react';\r\n\r\ninterface ConnectionStatusProps {\r\n    baseUrl: string;\r\n\r\n    disconnectBackend: () => void;\r\n}\r\n\r\nexport const ConnectionStatus = (props: ConnectionStatusProps) => (\r\n    <div className='connection-status'>\r\n        <h2>Connection</h2>\r\n        <span>&#x1f5a7; You are connecting to: {props.baseUrl}</span>\r\n        <input className='button' type='button' onClick={props.disconnectBackend} value='Disconnect'></input>\r\n    </div>\r\n);","import React, { PureComponent } from 'react';\r\nimport { Profile } from '../Models/Profile';\r\nimport './ProfilePicker.css';\r\n\r\ninterface ProfileViewerProps {\r\n    profileArray: Profile[] | undefined;\r\n    selectedProfile: string | undefined;\r\n    onSelected: (newValue: string) => void;\r\n    onRefresh: () => void;\r\n}\r\n\r\nexport default class ProfileViewer extends PureComponent<ProfileViewerProps, any> {\r\n    render() {\r\n        let count = 0;\r\n        let content;\r\n        const profileArray = this.getValidProfile();\r\n\r\n        if (profileArray !== undefined) {\r\n            count = profileArray.length;\r\n            content = (<div className='ProfileListContainer'><select value={this.props.selectedProfile} onChange={e => {\r\n                const target = e.target as any;\r\n                if (!!target && !!target.value) {\r\n                    this.props.onSelected(target.value);\r\n                }\r\n            }}>{\r\n                    profileArray.sort((a, b) => a > b ? 1 : -1).map((profile) => {\r\n                        return <option key={profile.name} value={profile.name}>{profile.name}: {profile.description}</option>;\r\n                    })\r\n                }</select></div>);\r\n        } else {\r\n            content = \"No tracing profile exist.\"\r\n        }\r\n        return <div className='profile-picker'>\r\n            <div className='header'>\r\n                <h2>Tracing Profiles ({count})</h2>\r\n                <input className='button header-button refresh-button' type='button' onClick={this.props.onRefresh} value='&#x1f5d8;'></input>\r\n            </div>\r\n            {content}\r\n        </div>\r\n    }\r\n\r\n    getValidProfile: () => Profile[] | undefined = () => {\r\n        if (this.props.profileArray === undefined) {\r\n            return undefined;\r\n        }\r\n        return this.props.profileArray.filter(p => p.name !== 'none');\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport './Components/Processes'\r\nimport Process from './Models/Process';\r\nimport { TraceSession } from './Models/TraceSession';\r\n\r\nimport Processes from './Components/Processes';\r\nimport TraceSessions from './Components/TraceSessions';\r\nimport TraceFile from './Models/TraceFile';\r\nimport TraceRepo from './Components/TraceRepo';\r\nimport ConnectingToBackend from './Components/ConnectingToBackend';\r\nimport { AppHeader } from './Components/AppHeader';\r\nimport { ConnectionStatus } from './Components/ConnectionStatus';\r\nimport { Profile } from './Models/Profile';\r\nimport ProfilePicker from './Components/ProfilePicker';\r\n\r\ninterface AppState {\r\n  processArray: Process[] | undefined;\r\n  traceSessionArray: TraceSession[] | undefined;\r\n  traceFileArray: TraceFile[] | undefined;\r\n  isReady: boolean;\r\n  isBackendReady: boolean;\r\n  backendUrlArray: string[];\r\n  baseUrl: string;\r\n  profileArray: Profile[] | undefined;\r\n  selectedProfile: string | undefined;\r\n}\r\n\r\nexport default class App extends Component<any, AppState>{\r\n  readonly BackendListKey: string = 'backendList';\r\n  constructor(props: any) {\r\n    super(props);\r\n\r\n    // Initial state\r\n    this.state = {\r\n      processArray: undefined,\r\n      traceSessionArray: undefined,\r\n      traceFileArray: undefined,\r\n      isReady: false,\r\n      isBackendReady: false,\r\n      backendUrlArray: this.getList(),\r\n      baseUrl: '',\r\n      profileArray: undefined,\r\n      selectedProfile: undefined,\r\n    };\r\n  }\r\n  render() {\r\n    let content;\r\n\r\n    if (!this.state.isBackendReady) {\r\n      content = <ConnectingToBackend\r\n        backendUrlArray={this.state.backendUrlArray}\r\n        addBackend={this.addBackend}\r\n        removeBackend={this.removeBackend}\r\n        connectToBackendAsync={this.connectToBackendAsync}\r\n      />;\r\n    } else {\r\n      content = this.state.isReady ? (\r\n        <div>\r\n          <ConnectionStatus baseUrl={this.state.baseUrl}\r\n            disconnectBackend={this.disconnectBackend}\r\n          />\r\n          <ProfilePicker\r\n            profileArray={this.state.profileArray}\r\n            onSelected={this.selectProfile}\r\n            selectedProfile={this.state.selectedProfile}\r\n            onRefresh={this.LoadProfilesAsync}\r\n          />\r\n          <Processes\r\n            refreshProcessAsync={this.loadProcessesAsync}\r\n            startProfilingAsync={this.startProfilingAsync}\r\n            takeDumpAsync={this.takeDumpAsync}\r\n            processArray={this.state.processArray}\r\n          />\r\n          <TraceSessions\r\n            traceSessions={this.state.traceSessionArray}\r\n            stopProfilingAsync={this.stopProfilingAsync}\r\n            loadTraceSessionsAsync={this.loadTraceSessionsAsync} />\r\n          <TraceRepo\r\n            baseUrl={this.state.baseUrl}\r\n            loadTraceFilesAsync={this.loadTraceFilesAsync}\r\n            convertToSpeedscopeAsync={this.convertToSpeedscopeAsync}\r\n            fileArray={this.state.traceFileArray}\r\n          />\r\n        </div>\r\n      ) : null;\r\n    }\r\n\r\n    return (\r\n      <div className='dark-theme'>\r\n        <AppHeader />\r\n        <div className='app-container'>\r\n          {content}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private initializeAsync: () => Promise<any> = async () => {\r\n    await Promise.all([\r\n      this.loadProcessesAsync(),\r\n      this.loadTraceSessionsAsync(),\r\n      this.loadTraceFilesAsync(),\r\n      this.LoadProfilesAsync(),\r\n    ]);\r\n\r\n    this.selectProfile('runtime-basic');\r\n\r\n    this.setState({\r\n      isReady: true,\r\n    });\r\n  }\r\n\r\n  // Processes\r\n  private loadProcessesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const processes = await this.getProcessesAsync();\r\n      this.setState({\r\n        processArray: processes,\r\n      });\r\n    } catch (ex) {\r\n      this.setState({\r\n        processArray: undefined,\r\n      });\r\n    }\r\n  }\r\n  private getProcessesAsync: () => Promise<Process[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/processes`);\r\n    if (!!response && response.ok) {\r\n      const results: Process[] = await response.json();\r\n      return results;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Traces\r\n  private startProfilingAsync: (processId: number) => Promise<boolean> = async (processId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        processId: processId,\r\n        profile: this.state.selectedProfile,\r\n      }),\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await this.loadTraceSessionsAsync();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean> = async (processId: number, sessionId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces/${processId}?sessionId=${sessionId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await Promise.all([this.loadTraceSessionsAsync(), this.loadTraceFilesAsync()]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Sessions\r\n  private loadTraceSessionsAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const traceSessions = await this.getTraceSessionsAsync();\r\n      this.setState({\r\n        traceSessionArray: traceSessions,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceSessionArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceSessionsAsync: () => Promise<TraceSession[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/sessions`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceSession[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Repository\r\n  private loadTraceFilesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const files = await this.getTraceFilesAsync();\r\n      this.setState({\r\n        traceFileArray: files,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceFileArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceFilesAsync: () => Promise<TraceFile[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/traceFiles`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceFile[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  private convertToSpeedscopeAsync: (fileName: string) => Promise<boolean> = async (fileName) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traceFiles`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        fileName,\r\n      }),\r\n    });\r\n    if (!!response && response.ok) {\r\n      await this.loadTraceFilesAsync();\r\n      return true;\r\n    } else {\r\n      const error = await response.json();\r\n\r\n      alert('Converting failed.' + !!error.error ? ' Details: ' + error.error : '');\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Backend\r\n  private addBackend: (url: string) => void = (url: string) => {\r\n    url = url.toLowerCase();\r\n    const list = this.getList();\r\n    if (!list.includes(url)) {\r\n      list.push(url);\r\n    }\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private removeBackend: (url: string) => void = (url: string): void => {\r\n    url = url.toLowerCase();\r\n    let list = this.getList();\r\n    list = list.filter(item => item !== url);\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private getList(): string[] {\r\n    const urlListSerialized: string | null = localStorage.getItem(this.BackendListKey);\r\n    let list: string[];\r\n    if (urlListSerialized === null || urlListSerialized === '' || urlListSerialized === '[]') {\r\n      list = ['http://localhost:9400'];\r\n    } else {\r\n      list = JSON.parse(urlListSerialized);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  private disconnectBackend: () => void = () => {\r\n    this.setState({\r\n      baseUrl: '',\r\n      isReady: false,\r\n      isBackendReady: false,\r\n    });\r\n  }\r\n\r\n  private connectToBackendAsync: (url: string) => Promise<boolean> = async (url: string) => {\r\n    try {\r\n      url = url.trim();\r\n      if (!url.startsWith('http') && !url.startsWith('https')) {\r\n        return false;\r\n      }\r\n      if (url.endsWith('/')) {\r\n        url = url.substring(0, url.length - 1);\r\n      }\r\n      const response = await fetch(url + '/processes');\r\n      if (!!response && response.ok) {\r\n        this.setState({\r\n          isBackendReady: true,\r\n          baseUrl: url,\r\n        });\r\n        await this.initializeAsync();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Profiles\r\n  private LoadProfilesAsync: () => void = async () => {\r\n    const result = await this.getProfilesAsync();\r\n    if (result.length > 0) {\r\n      this.setState({\r\n        profileArray: result,\r\n      });\r\n    } else {\r\n      this.setState({\r\n        profileArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getProfilesAsync: () => Promise<Profile[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/profiles`);\r\n    if (!!response && response.ok) {\r\n      const result: Profile[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  private selectProfile: (newValue: string) => void = (newValue: string) => {\r\n    this.setState({\r\n      selectedProfile: newValue\r\n    });\r\n  }\r\n\r\n  // Dumps\r\n  private takeDumpAsync: (processId: number, isMini: boolean) => Promise<any> = async (processId, isMini) => {\r\n    const DUMP_TYPE_HEAP = 0;\r\n    const DUMP_TYPE_MINI = 1;\r\n    const dumpType = isMini ? DUMP_TYPE_MINI : DUMP_TYPE_HEAP;\r\n    const response = await fetch(`${this.state.baseUrl}/dumps`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        processId,\r\n        dumpType,\r\n      }),\r\n    });\r\n    if (!!response && response.ok) {\r\n      await this.loadTraceFilesAsync();\r\n      alert('Dump crated for process ' + processId);\r\n      return true;\r\n    } else {\r\n      alert('Failed to create the dump for this process: ' + processId);\r\n    }\r\n    return false;\r\n  }\r\n}","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}