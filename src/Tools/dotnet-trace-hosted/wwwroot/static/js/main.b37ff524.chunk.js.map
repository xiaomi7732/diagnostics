{"version":3,"sources":["Components/Processes.tsx","Components/TraceSessions.tsx","Components/TraceRepo.tsx","Components/ConnectingToBackend.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Processes","handleRefresh","event","a","preventDefault","stopPropagation","props","refreshProcessAsync","content","len","undefined","this","processArray","length","map","process","index","key","id","name","mainModule","type","value","onClick","console","debug","startProfilingAsync","Component","TraceSessions","list","traceSessions","session","processId","sessionId","stopProfilingAsync","loadTraceSessionsAsync","PureComponent","TraceRepo","fileArray","sort","b","fileName","file","href","baseUrl","alert","loadTraceFilesAsync","ConnectingToBackend","handleAddBackend","e","newValue","target","newBackend","addBackend","setState","newUrl","handleNewUrlChanged","state","errorMessage","isConnecting","backendUrlArray","url","connectToBackendAsync","removeBackend","onSubmit","htmlFor","placeholder","onChange","App","BackendListKey","initializeAsync","Promise","all","loadProcessesAsync","isReady","getProcessesAsync","processes","fetch","response","ok","json","results","method","headers","body","JSON","stringify","result","getTraceSessionsAsync","traceSessionArray","getTraceFilesAsync","files","traceFileArray","toLowerCase","getList","includes","push","localStorage","setItem","filter","item","disconnectBackend","isBackendReady","trim","startsWith","endsWith","substring","urlListSerialized","getItem","parse","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b37ff524.chunk.js","sourcesContent":["import React, { Component, ReactNode } from 'react';\r\nimport Process from '../Models/Process';\r\ninterface ProcessesProps {\r\n    refreshProcessAsync: () => Promise<void>;\r\n    startProfilingAsync: (processId: number) => Promise<boolean>;\r\n    processArray: Process[] | undefined;\r\n}\r\n\r\nexport default class Processes extends Component<ProcessesProps, {}>{\r\n    render(): ReactNode {\r\n        let content;\r\n        let len = 0;\r\n\r\n        if (this.props.processArray === undefined || this.props.processArray.length === 0) {\r\n            content = (<div>\r\n                There is no .NET Core processes.\r\n            </div>);\r\n        } else {\r\n            len = this.props.processArray.length;\r\n            content = this.props.processArray.map((process: Process, index: number) => {\r\n                return (<div key={index}>\r\n                    <span>{process.id}</span>-<span>{process.name}</span>-<span>{process.mainModule}</span>\r\n                    <input type='button' value='Start Profiling'\r\n                        onClick={() => {\r\n                            console.debug(`Start Profiling for session: ${process.id}`)\r\n                            this.props.startProfilingAsync(process.id)\r\n                        }} />\r\n                </div>)\r\n            });\r\n        }\r\n\r\n        return (<div>\r\n            <h2>Process ({len})</h2>\r\n            {content}\r\n            <input type='button' onClick={this.handleRefresh} value='Refresh'></input>\r\n        </div>\r\n        );\r\n    }\r\n\r\n    private handleRefresh = async (event: React.MouseEvent<HTMLInputElement, MouseEvent>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.props.refreshProcessAsync();\r\n    }\r\n}\r\n\r\n\r\n","import React, { PureComponent } from 'react';\r\nimport { TraceSession } from '../Models/TraceSession';\r\n\r\ninterface TraceSessionsProps {\r\n    loadTraceSessionsAsync: () => Promise<void>;\r\n    stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean>;\r\n    traceSessions: TraceSession[] | undefined;\r\n}\r\n\r\nexport default class TraceSessions extends PureComponent<TraceSessionsProps, {}>{\r\n    render() {\r\n        let list;\r\n        let len: number = 0;\r\n\r\n        if (this.props.traceSessions === undefined || this.props.traceSessions.length === 0) {\r\n            list = <div>There's no trace sessions.</div>\r\n        }\r\n        else {\r\n            len = this.props.traceSessions.length;\r\n            list = <div>\r\n                {this.props.traceSessions.map((session, index) => {\r\n                    return (<div key={index}>\r\n                        <span>ProcessId:</span>\r\n                        <span>{session.processId}</span>&nbsp;\r\n                        <span>SessionId:</span>\r\n                        <span>{session.sessionId}</span>&nbsp;\r\n                        <input type='button' value='Stop Profiling' onClick={() => {\r\n                            console.debug(`Stopping profiler: ${session.processId}:${session.sessionId}`);\r\n                            this.props.stopProfilingAsync(session.processId, session.sessionId);\r\n                        }} />\r\n                    </div>);\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div>\r\n            <h2>Trace Sessions ({len})</h2>\r\n            {list}\r\n            <input type='button' value='Refresh' onClick={this.props.loadTraceSessionsAsync} />\r\n        </div>);\r\n    }\r\n}","import React, { PureComponent } from 'react';\r\nimport TraceFile from '../Models/TraceFile';\r\n\r\ninterface TraceRepoProps {\r\n    baseUrl: string;\r\n    loadTraceFilesAsync: () => Promise<void>;\r\n    fileArray: TraceFile[] | undefined;\r\n}\r\n\r\nexport default class TraceRepo extends PureComponent<TraceRepoProps, {}>{\r\n    render() {\r\n        let content;\r\n        let len: number = 0;\r\n        if (this.props.fileArray === undefined || this.props.fileArray.length === 0) {\r\n            content = <div>There's no trace file.</div>\r\n        } else {\r\n            len = this.props.fileArray.length;\r\n            content = <div>\r\n                {this.props.fileArray.sort((a, b) => {\r\n                    return a.fileName > b.fileName ? -1 : 1;\r\n                }).map((file, index) => {\r\n                    return <div key={index}>\r\n                        <a href={`${this.props.baseUrl}/TraceFiles/${file.fileName}`}>{file.fileName}</a>\r\n                        <input type='button' value='Upload to SP Backend' onClick={() => alert(`Not implemented: ${file.fileName}`)} />\r\n                    </div>\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div>\r\n            <h2>Trace Files ({len})</h2>\r\n            {content}\r\n            <input type='button' value='Refresh' onClick={async () => await this.props.loadTraceFilesAsync()}></input>\r\n        </div>)\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\ninterface ConnectingToBackendProps {\r\n    backendUrlArray: string[] | undefined,\r\n    connectToBackendAsync: (url: string) => Promise<boolean>;\r\n    addBackend: (newUrl: string) => void;\r\n    removeBackend: (targetUrl: string) => void;\r\n}\r\n\r\ninterface ConnectingToBackendState {\r\n    errorMessage: string | undefined;\r\n    isConnecting: boolean;\r\n    newUrl: string;\r\n}\r\n\r\nexport default class ConnectingToBackend extends Component<ConnectingToBackendProps, ConnectingToBackendState>{\r\n    constructor(props: ConnectingToBackendProps) {\r\n        super(props);\r\n        this.state = {\r\n            errorMessage: undefined,\r\n            isConnecting: false,\r\n            newUrl: '',\r\n        };\r\n    }\r\n    render() {\r\n        let content;\r\n        if (this.props.backendUrlArray === undefined || this.props.backendUrlArray.length === 0) {\r\n            content = <div>Please add backend.</div>\r\n        } else {\r\n            content = this.props.backendUrlArray.map((url, index) => {\r\n                return <div key={index}>\r\n                    <span>{url}</span>\r\n                    <input type='button' value='Connect' onClick={async () => {\r\n                        this.setState({\r\n                            errorMessage: '',\r\n                            isConnecting: true,\r\n                        });\r\n                        const result = await this.props.connectToBackendAsync(url);\r\n                        if (!result) {\r\n                            this.setState({\r\n                                errorMessage: `Failed to connecting to backend: ${url}.`,\r\n                                isConnecting: false,\r\n                            });\r\n                        }\r\n                    }}></input>\r\n                    <input type='button' value='Remove' onClick={async () => {\r\n                        this.props.removeBackend(url);\r\n                    }}></input>\r\n                </div>\r\n            })\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                <h1>.NET Core Profiling Console</h1>\r\n                <div>\r\n                    <span>Pick a backend to connect to:</span>\r\n                    {content}\r\n                    {!!this.state.isConnecting && <div>Connecting . . .</div>}\r\n                    {!!this.state.errorMessage && <div>{this.state.errorMessage}</div>}\r\n                </div>\r\n\r\n                <div>\r\n                    <form onSubmit={this.handleAddBackend}>\r\n                        <label htmlFor='newBackend'>Type in a new endpoint:</label>\r\n                        <input id='newBackend' type='textbox' placeholder='http://localhost:9400'\r\n                            value={this.state.newUrl} onChange={this.handleNewUrlChanged} />\r\n                    </form>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    handleAddBackend = (e: React.FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        const target = e.target as any;\r\n        const newValue = target.newBackend.value;\r\n        if (!!newValue) {\r\n            this.props.addBackend(newValue);\r\n            this.setState({\r\n                newUrl: ''\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNewUrlChanged = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({\r\n            newUrl: e.target.value,\r\n        });\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport './Components/Processes'\r\nimport Process from './Models/Process';\r\nimport { TraceSession } from './Models/TraceSession';\r\n\r\nimport Processes from './Components/Processes';\r\nimport TraceSessions from './Components/TraceSessions';\r\nimport TraceFile from './Models/TraceFile';\r\nimport TraceRepo from './Components/TraceRepo';\r\nimport ConnectingToBackend from './Components/ConnectingToBackend';\r\n\r\ninterface AppState {\r\n  processArray: Process[] | undefined;\r\n  traceSessionArray: TraceSession[] | undefined;\r\n  traceFileArray: TraceFile[] | undefined;\r\n  isReady: boolean;\r\n  isBackendReady: boolean;\r\n  backendUrlArray: string[];\r\n  baseUrl: string;\r\n}\r\n\r\nexport default class App extends Component<any, AppState>{\r\n  readonly BackendListKey: string = 'backendList';\r\n  constructor(props: any) {\r\n    super(props);\r\n\r\n    // Initial state\r\n    this.state = {\r\n      processArray: undefined,\r\n      traceSessionArray: undefined,\r\n      traceFileArray: undefined,\r\n      isReady: false,\r\n      isBackendReady: false,\r\n      backendUrlArray: this.getList(),\r\n      baseUrl: '',\r\n    };\r\n  }\r\n  render() {\r\n    if (!this.state.isBackendReady) {\r\n      return (<ConnectingToBackend\r\n        backendUrlArray={this.state.backendUrlArray}\r\n        addBackend={this.addBackend}\r\n        removeBackend={this.removeBackend}\r\n        connectToBackendAsync={this.connectToBackendAsync}\r\n      />);\r\n    } else {\r\n      return this.state.isReady ? (\r\n        <div>\r\n          <h1>.NET Core Profiling Console</h1>\r\n          <div>\r\n            <span>You are connecting to: {this.state.baseUrl}</span>\r\n            <input type='button' onClick={this.disconnectBackend} value='Disconnect'></input>\r\n          </div>\r\n          <Processes\r\n            refreshProcessAsync={this.loadProcessesAsync}\r\n            startProfilingAsync={this.startProfilingAsync}\r\n            processArray={this.state.processArray}\r\n          />\r\n          <TraceSessions\r\n            traceSessions={this.state.traceSessionArray}\r\n            stopProfilingAsync={this.stopProfilingAsync}\r\n            loadTraceSessionsAsync={this.loadTraceSessionsAsync} />\r\n          <TraceRepo\r\n            baseUrl={this.state.baseUrl}\r\n            loadTraceFilesAsync={this.loadTraceFilesAsync}\r\n            fileArray={this.state.traceFileArray}\r\n          />\r\n        </div>\r\n      ) : null;\r\n    }\r\n  }\r\n\r\n  private initializeAsync: () => Promise<any> = async () => {\r\n    await Promise.all([\r\n      this.loadProcessesAsync(),\r\n      this.loadTraceSessionsAsync(),\r\n      this.loadTraceFilesAsync(),\r\n    ]);\r\n\r\n    this.setState({\r\n      isReady: true,\r\n    });\r\n  }\r\n\r\n  // Processes\r\n  private loadProcessesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const processes = await this.getProcessesAsync();\r\n      this.setState({\r\n        processArray: processes,\r\n      });\r\n    } catch (ex) {\r\n      this.setState({\r\n        processArray: undefined,\r\n      });\r\n    }\r\n  }\r\n  private getProcessesAsync: () => Promise<Process[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/processes`);\r\n    if (!!response && response.ok) {\r\n      const results: Process[] = await response.json();\r\n      return results;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Traces\r\n  private startProfilingAsync: (processId: number) => Promise<boolean> = async (processId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        processId: processId\r\n      }),\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await this.loadTraceSessionsAsync();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean> = async (processId: number, sessionId: number) => {\r\n    const response = await fetch(`${this.state.baseUrl}/traces/${processId}?sessionId=${sessionId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    const result = !!response && response.ok;\r\n    if (result) {\r\n      await Promise.all([this.loadTraceSessionsAsync(), this.loadTraceFilesAsync()]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Sessions\r\n  private loadTraceSessionsAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const traceSessions = await this.getTraceSessionsAsync();\r\n      this.setState({\r\n        traceSessionArray: traceSessions,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceSessionArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceSessionsAsync: () => Promise<TraceSession[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/sessions`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceSession[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Repository\r\n  private loadTraceFilesAsync: () => Promise<void> = async () => {\r\n    try {\r\n      const files = await this.getTraceFilesAsync();\r\n      this.setState({\r\n        traceFileArray: files,\r\n      });\r\n    } catch{\r\n      this.setState({\r\n        traceFileArray: undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  private getTraceFilesAsync: () => Promise<TraceFile[]> = async () => {\r\n    const response = await fetch(`${this.state.baseUrl}/traceFiles`);\r\n    if (!!response && response.ok) {\r\n      const result: TraceFile[] = await response.json();\r\n      return result;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Backend\r\n  private addBackend: (url: string) => void = (url: string) => {\r\n    url = url.toLowerCase();\r\n    const list = this.getList();\r\n    if (!list.includes(url)) {\r\n      list.push(url);\r\n    }\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private removeBackend: (url: string) => void = (url: string): void => {\r\n    url = url.toLowerCase();\r\n    let list = this.getList();\r\n    list = list.filter(item => item !== url);\r\n    localStorage.setItem(this.BackendListKey, JSON.stringify(list));\r\n    this.setState({\r\n      backendUrlArray: list\r\n    });\r\n  }\r\n\r\n  private getList(): string[] {\r\n    const urlListSerialized: string | null = localStorage.getItem(this.BackendListKey);\r\n    let list: string[];\r\n    if (urlListSerialized === null || urlListSerialized === '') {\r\n      list = [];\r\n    } else {\r\n      list = JSON.parse(urlListSerialized);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  private disconnectBackend: () => void = () => {\r\n    this.setState({\r\n      baseUrl: '',\r\n      isReady: false,\r\n      isBackendReady: false,\r\n    });\r\n  }\r\n\r\n  private connectToBackendAsync: (url: string) => Promise<boolean> = async (url: string) => {\r\n    try {\r\n      url = url.trim();\r\n      if (!url.startsWith('http') && !url.startsWith('https')) {\r\n        return false;\r\n      }\r\n      if (url.endsWith('/')) {\r\n        url = url.substring(0, url.length - 1);\r\n      }\r\n      const response = await fetch(url + '/processes');\r\n      if (!!response && response.ok) {\r\n        this.setState({\r\n          isBackendReady: true,\r\n          baseUrl: url,\r\n        });\r\n        await this.initializeAsync();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}