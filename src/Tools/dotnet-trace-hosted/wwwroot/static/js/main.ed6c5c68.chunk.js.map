{"version":3,"sources":["Components/Processes.tsx","Components/TraceSessions.tsx","Components/TraceRepo.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Processes","handleRefresh","event","a","preventDefault","stopPropagation","props","refreshProcessAsync","content","len","undefined","this","processArray","length","map","process","index","key","id","name","mainModule","type","value","onClick","console","debug","startProfilingAsync","Component","TraceSessions","list","traceSessions","session","processId","sessionId","stopProfilingAsync","loadTraceSessionsAsync","PureComponent","TraceRepo","fileArray","sort","b","fileName","file","href","baseUrl","alert","loadTraceFilesAsync","App","BaseUrl","initializeAsync","Promise","all","loadProcessesAsync","setState","isReady","getProcessesAsync","processes","fetch","response","ok","json","results","method","headers","body","JSON","stringify","result","getTraceSessionsAsync","traceSessionArray","getTraceFilesAsync","files","traceFileArray","state","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ed6c5c68.chunk.js","sourcesContent":["import React, { Component, ReactNode } from 'react';\r\nimport Process from '../Models/Process';\r\ninterface ProcessesProps {\r\n    refreshProcessAsync: () => Promise<void>;\r\n    startProfilingAsync: (processId: number) => Promise<boolean>;\r\n    processArray: Process[] | undefined;\r\n}\r\n\r\nexport default class Processes extends Component<ProcessesProps, {}>{\r\n    render(): ReactNode {\r\n        let content;\r\n        let len = 0;\r\n\r\n        if (this.props.processArray === undefined || this.props.processArray.length === 0) {\r\n            content = (<div>\r\n                There is no .NET Core processes.\r\n            </div>);\r\n        } else {\r\n            len = this.props.processArray.length;\r\n            content = this.props.processArray.map((process: Process, index: number) => {\r\n                return (<div key={index}>\r\n                    <span>{process.id}</span>-<span>{process.name}</span>-<span>{process.mainModule}</span>\r\n                    <input type='button' value='Start Profiling'\r\n                        onClick={() => {\r\n                            console.debug(`Start Profiling for session: ${process.id}`)\r\n                            this.props.startProfilingAsync(process.id)\r\n                        }} />\r\n                </div>)\r\n            });\r\n        }\r\n\r\n        return (<div>\r\n            <h2>Process ({len})</h2>\r\n            {content}\r\n            <input type='button' onClick={this.handleRefresh} value='Refresh'></input>\r\n        </div>\r\n        );\r\n    }\r\n\r\n    private handleRefresh = async (event: React.MouseEvent<HTMLInputElement, MouseEvent>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.props.refreshProcessAsync();\r\n    }\r\n}\r\n\r\n\r\n","import React, { PureComponent } from 'react';\r\nimport { TraceSession } from '../Models/TraceSession';\r\n\r\ninterface TraceSessionsProps {\r\n    loadTraceSessionsAsync: () => Promise<void>;\r\n    stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean>;\r\n    traceSessions: TraceSession[] | undefined;\r\n}\r\n\r\nexport default class TraceSessions extends PureComponent<TraceSessionsProps, {}>{\r\n    render() {\r\n        let list;\r\n        let len: number = 0;\r\n\r\n        if (this.props.traceSessions === undefined || this.props.traceSessions.length === 0) {\r\n            list = <div>There's no trace sessions.</div>\r\n        }\r\n        else {\r\n            len = this.props.traceSessions.length;\r\n            list = <div>\r\n                {this.props.traceSessions.map((session, index) => {\r\n                    return (<div key={index}>\r\n                        <span>ProcessId:</span>\r\n                        <span>{session.processId}</span>&nbsp;\r\n                        <span>SessionId:</span>\r\n                        <span>{session.sessionId}</span>&nbsp;\r\n                        <input type='button' value='Stop Profiling' onClick={() => {\r\n                            console.debug(`Stopping profiler: ${session.processId}:${session.sessionId}`);\r\n                            this.props.stopProfilingAsync(session.processId, session.sessionId);\r\n                        }} />\r\n                    </div>);\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div>\r\n            <h2>Trace Sessions ({len})</h2>\r\n            {list}\r\n            <input type='button' value='Refresh' onClick={this.props.loadTraceSessionsAsync} />\r\n        </div>);\r\n    }\r\n}","import React, { PureComponent } from 'react';\r\nimport TraceFile from '../Models/TraceFile';\r\n\r\ninterface TraceRepoProps {\r\n    baseUrl: string;\r\n    loadTraceFilesAsync: () => Promise<void>;\r\n    fileArray: TraceFile[] | undefined;\r\n}\r\n\r\nexport default class TraceRepo extends PureComponent<TraceRepoProps, {}>{\r\n    render() {\r\n        let content;\r\n        let len: number = 0;\r\n        if (this.props.fileArray === undefined || this.props.fileArray.length === 0) {\r\n            content = <div>There's no trace file.</div>\r\n        } else {\r\n            len = this.props.fileArray.length;\r\n            content = <div>\r\n                {this.props.fileArray.sort((a, b) => {\r\n                    return a.fileName > b.fileName ? -1 : 1;\r\n                }).map((file, index) => {\r\n                    return <div key={index}>\r\n                        <a href={`${this.props.baseUrl}/TraceFiles/${file.fileName}`}>{file.fileName}</a>\r\n                        <input type='button' value='Upload to SP Backend' onClick={() => alert(`Not implemented: ${file.fileName}`)} />\r\n                    </div>\r\n                })}\r\n            </div>\r\n        }\r\n        return (<div>\r\n            <h2>Trace Files ({len})</h2>\r\n            {content}\r\n            <input type='button' value='Refresh' onClick={async () => await this.props.loadTraceFilesAsync()}></input>\r\n        </div>)\r\n    }\r\n}","import React, { Component } from 'react';\nimport './App.css';\nimport './Components/Processes'\nimport Process from './Models/Process';\nimport { TraceSession } from './Models/TraceSession';\n\nimport Processes from './Components/Processes';\nimport TraceSessions from './Components/TraceSessions';\nimport TraceFile from './Models/TraceFile';\nimport TraceRepo from './Components/TraceRepo';\n\ninterface AppState {\n  processArray: Process[] | undefined;\n  traceSessionArray: TraceSession[] | undefined;\n  traceFileArray: TraceFile[] | undefined;\n  isReady: boolean;\n}\n\nexport default class App extends Component<any, AppState>{\n  readonly BaseUrl: string = 'http://localhost:9400'\n\n  constructor(props: any) {\n    super(props);\n\n    // Initial state\n    this.state = {\n      processArray: undefined,\n      traceSessionArray: undefined,\n      traceFileArray: undefined,\n      isReady: false,\n    };\n\n    this.initializeAsync();\n  }\n  render() {\n    return this.state.isReady ? (\n      <div>\n        <h1>.NET Core Profiling Console</h1>\n        <Processes\n          refreshProcessAsync={this.loadProcessesAsync}\n          startProfilingAsync={this.startProfilingAsync}\n          processArray={this.state.processArray}\n        />\n        <TraceSessions\n          traceSessions={this.state.traceSessionArray}\n          stopProfilingAsync={this.stopProfilingAsync}\n          loadTraceSessionsAsync={this.loadTraceSessionsAsync} />\n        <TraceRepo\n          baseUrl={this.BaseUrl}\n          loadTraceFilesAsync={this.loadTraceFilesAsync}\n          fileArray={this.state.traceFileArray}\n        />\n      </div>\n    ) : null;\n  }\n\n  private initializeAsync: () => Promise<any> = async () => {\n    await Promise.all([\n      this.loadProcessesAsync(),\n      this.loadTraceSessionsAsync(),\n      this.loadTraceFilesAsync(),\n    ]);\n\n    this.setState({\n      isReady: true,\n    });\n  }\n\n  // Processes\n  private loadProcessesAsync: () => Promise<void> = async () => {\n    try {\n      const processes = await this.getProcessesAsync();\n      this.setState({\n        processArray: processes,\n      });\n    } catch (ex) {\n      this.setState({\n        processArray: undefined,\n      });\n    }\n  }\n  private getProcessesAsync: () => Promise<Process[]> = async () => {\n    const response = await fetch(`${this.BaseUrl}/processes`);\n    if (!!response && response.ok) {\n      const results: Process[] = await response.json();\n      return results;\n    }\n    return [];\n  }\n\n  // Traces\n  private startProfilingAsync: (processId: number) => Promise<boolean> = async (processId: number) => {\n    const response = await fetch(`${this.BaseUrl}/traces`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        processId: processId\n      }),\n    });\n\n    const result = !!response && response.ok;\n    if (result) {\n      await this.loadTraceSessionsAsync();\n    }\n    return result;\n  }\n\n  private stopProfilingAsync: (processId: number, sessionId: number) => Promise<boolean> = async (processId: number, sessionId: number) => {\n    const response = await fetch(`${this.BaseUrl}/traces/${processId}?sessionId=${sessionId}`, {\n      method: 'DELETE',\n    });\n\n    const result = !!response && response.ok;\n    if (result) {\n      await Promise.all([this.loadTraceSessionsAsync(), this.loadTraceFilesAsync()]);\n    }\n    return result;\n  }\n\n  // Sessions\n  private loadTraceSessionsAsync: () => Promise<void> = async () => {\n    try {\n      const traceSessions = await this.getTraceSessionsAsync();\n      this.setState({\n        traceSessionArray: traceSessions,\n      });\n    } catch{\n      this.setState({\n        traceSessionArray: undefined,\n      });\n    }\n  }\n\n  private getTraceSessionsAsync: () => Promise<TraceSession[]> = async () => {\n    const response = await fetch(`${this.BaseUrl}/sessions`);\n    if (!!response && response.ok) {\n      const result: TraceSession[] = await response.json();\n      return result;\n    }\n    return [];\n  }\n\n  // Repository\n  private loadTraceFilesAsync: () => Promise<void> = async () => {\n    try {\n      const files = await this.getTraceFilesAsync();\n      this.setState({\n        traceFileArray: files,\n      });\n    } catch{\n      this.setState({\n        traceFileArray: undefined,\n      });\n    }\n  }\n\n  private getTraceFilesAsync: () => Promise<TraceFile[]> = async () => {\n    const response = await fetch(`${this.BaseUrl}/traceFiles`);\n    if (!!response && response.ok) {\n      const result: TraceFile[] = await response.json();\n      return result;\n    }\n    return [];\n  }\n}\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}